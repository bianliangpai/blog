## 关于扩展语言的一些思考
### 背景
近日，在学习 github 上的 c++ trending 项目时，看到了一个 web 应用层框架，叫作 [drogon](https://github.com/drogonframework/drogon)。
drogon 中有一个模块叫作 drogon_ctl。在初次阅读 drogon 的组织方式时，我就被 drogon_ctl 吸引了。  
drogon_ctl 是一种将配置文件转换为代码的预处理工具，用法上非常类似于 google protobuf 项目中的 protoc。  
使用时，先使用构建工具（如 cmake）配置好 code package 之间的依赖关系，确保相关上层业务都依赖 drogon_ctl 所在的 package；同时，将构建过程中所需要的种种操作写在构建脚本（如 CMakeLists.txt 和 .cmake）中。  
构建时，构建工具会先调用 drogon_ctl 将配置文件逐一生成代码（如 .cpp），进而把生成后的源码文件加入上层业务所在 target 的 sources 中，共同参与 target 的编译。  
这样做的好处是，drogon 中大量不同名字但逻辑相同的业务被简化，此类业务的新增和维护变得更加容易。  
drogon 让我第一次[1](#备注)意识到可以在通信以外的地方感受到扩展语言\代码生成的魅力，进而引发了我最近对这个方面的强烈兴趣。  
### 探索
于是在兴趣的驱使下，我开始看 drogon_ctl 的源码，想要知道它究竟是怎么实现的。  
结果却令我大失所望，drogon_ctl 的实现其实就是搜索 template source file 中的特定符号，并根据预先规定的每个符号的特定含义，将 template source file 中的这些符号替换为配置文件中写死的特定 string。  
这种现实令人无法接受。  
我转而打开了 protobuf 的源码[2](#备注)，想确认一下 protobuf 是否其实也就是非常复杂的文本替换[3](备注)。而这次，我找到了自己想要的东西。  
protoc 的源码非常多，截止现在我也没能完整的看完 protoc 里所有的逻辑，但这不影响我看到自己想要的东西。  
靠着 intellisense 跳转过了 command parser 后，lexer 的概念出现在我眼前。  
由于对这个名词有点印象，直觉告诉我这里应该是一个通用的概念[4](#备注)。  
果然，google 的结果满足了我一开始的假设：这个从配置文件到代码的转换的过程是可以和编译里的相关概念联系起来的。  
所以其实这些配置文件从某种意义上来说也属于某一种语言[5](#备注)。  
换句话说，这种配置文件到代码转换的过程其实可以对应到编译原理里从源码到目标码的转换过程。  
### 学习

### 思考和感悟
1. 模板\参数配置文件解析主要用于消除重复代码（consoler launch、drogon）  
2. 代码生成主要用于将一种语言转换为另一种语言（protobuf、qt moc）  
3. 扩展阅读，https://doc.qt.io/archives/qt-4.8/templates.html  
## 备注
[1] 日后回忆起来，真正第一次见到此类用法是在 Qt Signal&Slot 中，但当时并没有意识到这一点。  
[2] 说起来之前第一次听说代码生成的时候，居然没想着去看看实现。  
[3] 其实如果想要了解 protobuf 的原理，通过搜索相关文章的方式会更快也更合理。直接去搜源码并不是很好的方式。  
[4] 要靠直觉间接搜索才能意识到这一点，也可以说是非常的菜了。  
[5] 后来才回忆起，json, xml 等从定义上来说就属于语言。
