## 关于扩展语言的一些思考
### 背景
近日，在学习 github 上的 c++ trending 项目时，看到了一个 web 应用层框架，叫作 [drogon](https://github.com/drogonframework/drogon)。
drogon 中有一个模块叫作 drogon_ctl。在初次阅读 drogon 的组织方式时，我就被 drogon_ctl 吸引了。  
drogon_ctl 是一种将配置文件转换为代码的预处理工具，用法上非常类似于 google protobuf 项目中的 protoc。  
使用时，先使用构建工具（如 cmake）配置好 code package 之间的依赖关系，确保相关上层业务都依赖 drogon_ctl 所在的 package；同时，将构建过程中所需要的种种操作写在构建脚本（如 CMakeLists.txt 和 .cmake）中。  
构建时，构建工具会先调用 drogon_ctl 将配置文件逐一生成代码（如 .cpp），进而把生成后的源码文件加入上层业务所在 target 的 sources 中，共同参与 target 的编译。  
这样做的好处是，drogon 中大量不同名字但逻辑相同的业务被简化，此类业务的新增和维护变得更加容易。  
drogon 让我第一次[1](#备注)意识到可以在通信以外的地方感受到扩展语言\代码生成的魅力，进而引发了我最近对这个方面的强烈兴趣。  
### 探索
于是在兴趣的驱使下，我开始看 drogon_ctl 的源码，想要知道它究竟是怎么实现的。  
结果却令我大失所望，drogon_ctl 的实现其实就是搜索 template source file 中的特定符号，并根据预先规定的每个符号的特定含义，将 template source file 中的这些符号替换为配置文件中写死的特定 string。  
这种现实令人无法接受。  
我转而打开了 protobuf 的源码[2](#备注)，想确认一下 protobuf 是否其实也就是非常复杂的文本替换[3](备注)。而这次，我找到了自己想要的东西。  
protoc 的源码非常多，截止现在我也没能完整的看完 protoc 里所有的逻辑，但这不影响我看到自己想要的东西。  
靠着 intellisense 跳转过了 command parser 后，lexer 的概念出现在我眼前。  
由于对这个名词有点印象，直觉告诉我这里应该是一个通用的概念[4](#备注)。  
果然，google 的结果满足了我一开始的假设：这个从配置文件到代码的转换的过程是可以和编译里的相关概念联系起来的。  
所以其实这些配置文件从某种意义上来说也属于某一种语言[5](#备注)。  
换句话说，这种配置文件到代码转换的过程其实可以对应到编译原理里从源码到目标码的转换过程。  
### 学习
在兴趣和多年遗憾的共同驱使下，我开始第N次重新学习编译原理。不过与以往不同，这次找到了一个非常适合上手的[材料](https://lotabout.me/2015/write-a-C-interpreter-0/)。  
这位博主的教学方法与其他材料的不同之处在于，他尽量简化了理论的部分、简化了语法、简化了汇编指令集[6](#备注)，用最简单的方式实现了一个 c 语言的解释器。  
花了一个小时先简单的浏览了一遍后，决定开始动手。  
#### 汇编指令集和 while true 虚拟机
这一部分最有价值的点在于用一段内存来模拟进程地址空间，用变量来模拟各个寄存器的使用、各个指令的作用（与栈的配合），让人非常直观的感受到了计算机底层的运行逻辑。  
过去我总不理解为什么要有这么多指令或是这么多寄存器，不同指令架构究竟是如何影响运行效率的，函数调用的入栈出栈和数据结构里的栈究竟有哪些不同。  
在跟着教程手动模拟一遍之后，这些问题全部都迎刃而解。  
不同的寄存器决定了运行时可以执行的操作的数量，寄存器的数量是效率与成本之间博弈后的结果；  
不同的指令架构决定了计算机执行指令的模式、周期和流水性能，指令设计地差（比如教程中设计的这一种，每次 ADD 计算都需要访存）自然执行效率就会很差；  
内存中的栈跟数据结构的栈就是有一定差距，不能完全挪用类比。只有跟着程序运行过一遍后，才能感受到 pc、sp、bp 等寄存器，push、pop等指令集是如何与栈巧妙地协同工作的；  
再次感叹计算机是实践性很强的学科，有条件的话一定要自己动手试一试，哪怕只是运行一遍别人现成的代码。  
#### 词法分析
词法分析中规中矩，特别想记录下来的是简化语法的想法。  
犹记得当年还没动手，先被繁杂的语法吓住了，而忘记了这个实验最重要的部分是什么。  
#### 语法分析
“材料”中第二值得重点强调的部分，就是文法与实现对应的非常紧密的语法分析了（几乎就是一一对应的，以至于我也能看到语法当场开始写实现）。  
犹记得当年实验时，满脑子都在想如何才能表示一棵抽象语法树，数据结构上如何设计[7](#备注)等等，完全没考虑过其实不一定真的要有一棵树存在[8](#备注)。  
完全理解“材料”里的对 LL(0) 的实现后，又一次感叹树这种东西的精妙。  
#### 其他
“材料”中并没有做语法制导翻译、IR 等部分，这也是这份材料值得一提的优点：只介绍了最核心、最影响对整个过程的理解的部分。  
而且，内容的精简也有利于学习时速战速决，不拖泥带水。  
### 思考和感悟
在感觉自己理解了编译（从语言到另一种语言）的过程之后，就立刻迫不及待地想要在工作中加入一些相关的内容了。  
在思考“哪些问题比较适合于用编译的技术来解决”时，我第一时间想到以下几种场景：  
1. 之前自己为业务写的调试工具中存在大量业务代码。可以试着用编译的技术，将配置文件生成 Gui 代码，减少自己的维护成本；  
2. 虽然我们的项目提倡 AOP，但 c++ 却并不支持 decorator 之类的语法。可以试着扩展 c++ 的语法，编译时使用构建工具调用预处理器对扩展后的语法进行处理，生成 c++ 编译器可以识别的语法内容； 
在进一步思考第一个场景时，我注意到这类问题并非只能用编译的方法来实现[9](备注)。结合 drogon 的设计，我将此类场景进一步总结为“为消除重复代码而设计”。暂时来看，这种场景下的问题通过读取配置文件并解析的方式反而更直观一些[10](#备注)。  
如果说编译并非银弹，那么很自然的想到“究竟什么问题才是最适合用编译来解决的”？  
以这种方式问出问题，答案也就变得很明显：具体问题具体分析，没有适合所有场景的设计。
最后，用 qt 的这篇关于为什么要通过扩展语言（moc）而非模板的方式来实现 signal&slot 的[文章](https://doc.qt.io/archives/qt-4.8/templates.html)作为结尾，是我目前找到的比较好的对此类技术选型的详细分析。  
希望日后能在此类问题上有更多的新的见解。  
## 备注
[1] 日后回忆起来，真正第一次见到此类用法是在 Qt Signal&Slot 中，但当时并没有意识到这一点。  
[2] 说起来之前第一次听说代码生成的时候，居然没想着去看看实现。  
[3] 其实如果想要了解 protobuf 的原理，通过搜索相关文章的方式会更快也更合理。直接去搜源码并不是很好的方式。  
[4] 要靠直觉间接搜索才能意识到这一点，也可以说是非常的菜了。  
[5] 后来才回忆起，json, xml 等从定义上来说就属于语言。  
[6] 也正是因为该指令集运行在自己构造的 while true "虚拟机" 上，极大简化了对汇编那一部分的调试和理解成本。  
[7] 当年做实验时选择了当时最“熟悉”的c++（事实上所谓“最熟悉”也就是刚接触STL，再次感叹太菜了），对当年的自己来说，用c++对表达这类事务有一定难度。  
[8] 记得同年做“高级数据结构设计”这门课的实验，坤妈疑惑于我的某个实现为什么这么慢，并最终发现我真的构造了某种结构来表达逻辑时，也发出了一声叹息。  
[9] 事实上，“调试工具”在使用 Gui 管理 Gui 的方式前，就是使用配置文件来对业务 Gui 进行管理。  
[10] 另一个问题是，如果即使通过编译技术转换出了 gui 代码，controller 的部分（如响应用户操作的 callback 函数）依然没法被简化掉。后来突然意识到，可以将 xml 等文件生成 gui 代码后，自动生成一个 callback 函数让用户去实现。最后意识到这其实就是 Qt creator。  
